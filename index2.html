<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0021)http://i-am-glow.com/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JSON-P DB Redux</title>
	
<meta name="description" content="">
<link rel="stylesheet" href="./icons-and-styles/style.css" title="yellow" type="text/css" media="screen">
	<link href="./icons-and-styles/prettify.css" type="text/css" rel="stylesheet">
    <script type="text/javascript" src="./icons-and-styles/prettify.js"></script>
	<style id="clearly_highlighting_css" type="text/css">/* selection */ html.clearly_highlighting_enabled ::-moz-selection { background: rgba(246, 238, 150, 0.99); } html.clearly_highlighting_enabled ::selection { background: rgba(246, 238, 150, 0.99); } /* cursor */ html.clearly_highlighting_enabled {    /* cursor and hot-spot position -- requires a default cursor, after the URL one */    cursor: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--cursor.png") 14 16, text; } /* highlight tag */ em.clearly_highlight_element {    font-style: inherit !important; font-weight: inherit !important;    background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--yellow.png");    background-repeat: repeat-x; background-position: top left; background-size: 100% 100%; } /* the delete-buttons are positioned relative to this */ em.clearly_highlight_element.clearly_highlight_first { position: relative; } /* delete buttons */ em.clearly_highlight_element a.clearly_highlight_delete_element {    display: none; cursor: pointer;    padding: 0; margin: 0; line-height: 0;    position: absolute; width: 34px; height: 34px; left: -17px; top: -17px;    background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--delete-sprite.png"); background-repeat: no-repeat; background-position: 0px 0px; } em.clearly_highlight_element a.clearly_highlight_delete_element:hover { background-position: -34px 0px; } /* retina */ @media (min--moz-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) {    em.clearly_highlight_element { background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--yellow@2x.png"); }    em.clearly_highlight_element a.clearly_highlight_delete_element { background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--delete-sprite@2x.png"); background-size: 68px 34px; } } </style><style>[touch-action="none"]{ -ms-touch-action: none; touch-action: none; }[touch-action="pan-x"]{ -ms-touch-action: pan-x; touch-action: pan-x; }[touch-action="pan-y"]{ -ms-touch-action: pan-y; touch-action: pan-y; }[touch-action="scroll"],[touch-action="pan-x pan-y"],[touch-action="pan-y pan-x"]{ -ms-touch-action: pan-x pan-y; touch-action: pan-x pan-y; }</style></head>

<body>

<div id="grid_hold">

<div id="header">
<div id="title"><span class="blog_title">JSON-P DB Redux</span></div>
<div id="about">
	
    JSON-P DB Redux utilizes Google App Engine's datastore in order to provide a persistent warehouse for arbitrary JSON objects that are made easily accessible from client-side javascript code via <a href="http://www.json.com/2007/12/24/jsonp-header-transfer-proposal/">JSON-P</a>.

</div>
</div>
<div id="content_hold">

		<h1>Welcome to GLOW</h1>
	<div id="content">
		<p><strong>We’re really proud to introduce GLOW – a WebGL wrapper. GLOW is for you who have some WebGL experience and would like to get to the core – shaders. Please try out GLOW for experimenting with shaders, to create your custom render pipe or make a WebGL demo. <a title="Fork!" href="https://github.com/empaempa/glow" target="_blank">Please fork here</a>.<br>
</strong></p>
<p>GLOW was initiated right after we finished <a title="ROME" href="http://ro.me/" target="_blank">ROME – Three Dreams of Black</a>. My main insight from ROME was the power of shaders and I wanted a way to work with this, not having to care about low-level WebGL and high-level abstractions.</p>
<p>Soon Olov Lassus joined and we’ve pushed GLOW to be clean and simple, yet powerful. Check out <a href="http://jsshaper.org/">JSShaper</a> and <a href="http://restrictmode.org/">Restrict Mode</a> that Olov is juggling as well.</p>
	</div>
	

		<span class="date">2012+09+04</span>
	<h1>Build With Chrome: GLego</h1>
	<div id="content">
		<p>I was driving too fast on the highway when the phone rang and I was asked by <a href="http://www.northkingdom.com/">North Kingdom</a> if I could help with a very specific task: to render as many Lego bricks as possible, using WebGL. I had no clue how to do it, but didn’t hesitate one second – of course, I’m in. Later that day, an idea landed and started to grow. After a lot of twists and turns, it ended up as <a href="http://buildwithchrome.com/">Build With Chrome</a> and a render technique I’ll try to explain here. But first… </p>
<h2>GLOW as Boilerplate</h2>
<p>The GLego-framework uses GLOW as boilerplate (that’s why this is posted on this blog) and it worked out pretty well. If you’re new to GLOW, it is a low level WebGL wrapper that does pretty much nothing but wraps the (sometimes) daunting WebGL API into something more readable.</p>
<p>There were some kinks that needed some ironing and missing features, which were added during the development. It’s all in the <a href="https://github.com/empaempa/GLOW">Github-repo now</a> if you like to use it. There might be some features missing but GLOW is pretty much “done” and ready to use in productions.</p>
<h2>Unity as Level Editor</h2>
<p>Even though our geometry is very simple, we needed a good middle man between whatever 3D-package the artists used and WebGL. We turned to the fantastic<a href="https://github.com/drojdjou/J3D"> J3D-Unity exporter by Bartek Drozdz</a>, modified it to our needs and was up and running. I highly recommend using this path, especially if you’re doing complex levels and stuff. You should be able to use the free version of Unity, without any practical limitations.</p>
<h2>The Build Renderer</h2>
<p>We needed two renderers – one for the build mode and one for the browse mode. The build mode renderer is just an ordinary renderer, using geometry and lights like most renderers do. To avoid WebGL state switching and keep performance up, the drawing order is optimized so the same type of geometry, colors and shaders is rendered in sequence. GLOW does the heavy lifting here, keeping track of all (or most) WebGL-states. The render loop pretty much looks like…</p>
<pre class="prettyprint">var type = renderCue.length,
  numColors = renderCue[ 0 ].length,
  color, objects, numObjects, object, c;

// draw all objects in type-color-order
while( type-- ) {
  color = numColors;
  while( color-- ) {
    objects = renderCue[ type ][ color ];
    numObjects = objects.length;
    while( numObjects-- ) {
      if( objects[ numObjects ].visible ) {
        objects[ numObjects ].draw();
      }
    }
  }
}

// draw all custom objects, using blend
glowContext.enableBlend( true );
c = customRenderCue.length;
while( c-- ) {
  if( customRenderCue[ c ].visible ) {
    customRenderCue[ c ].draw();
  }
}
glowContext.enableBlend( false );

// done!
</pre>
<p>There are no post-effects or anything, just plain simple… rendering. One of the real benefits of using GLOW is that your render loop becomes very readable.</p>
<h2>The Browse Renderer – Data</h2>
<p>The idea that landed that first day, spawned from how Lego-bricks are built around a very simple (genius) pattern. A brick has eight sides (only seven visible in Build with Chrome), a position, size and number of pegs that varies in discrete steps – we call them Lego Units (LU). A brick can only be rotated in steps of 90 degrees, which we don’t do in Build with Chrome – we simply switch width and depth. To describe a brick you simply need…</p>
<ul>
<li>Position: X, Y, Z in LU</li>
<li>Size: Width, height, depth in LU</li>
<li>Color</li>
</ul>
<p>Each building is placed on a baseplate, so the position for a single brick can be described in local baseplate coordinates and because no baseplate is bigger than 256 LU (it’s actually 32×32), each element of the position only needs an unsigned byte. This goes for the size as well. And to make things even better, there are a limited amount of types of bricks so width, height and depth can all be described with a type index, which fits in a byte. Finally, because there are a limited amount of Lego-colors, the color can be described as an index, which fits within a byte, too. So in the end, you only need 5 bytes to describe one brick: </p>
<p><strong>Position X, Y, Z in LU, Type and Color</strong>.</p>
<p>There are two huge upsides to this extremely compressed format: you can package and compress the data using PNG-images for fast data transfer (i think most buildings fit within a 50×50 pixels image). </p>
<p>You can (with some effort, admittedly) convert this into a single WebGL vec4 attribute and generate the geometry inside of a vertex shader, making it possible to render thousands of bricks in one single draw call. </p>
<h2>Browse Renderer – Deferred Rendering, Part 1</h2>
<p>To add even more complexity, the initial designs included some depth of field (DoF), vignetting and there was talk about using screen space ambient occlusion (SSAO) to get some kind of shadowing. SSAO didn’t make it in, due to lack of time and depth information (more about that soon).</p>
<p>Early on we had to make a decision: to go with a deferred approach or not. The cons were quite few – the obvious is lack of anti-aliasing, possibly multiple render passes and, it would turn out, some data problems. The pros includes less lighting calculations and simplified shaders, meaning more speed, which was a high priority. We went deferred.</p>
<p>We managed to find the holy grail of deferred rendering in WebGL – how to cope with a single rendering pass without having multiple render targets (MRT). The shaders simply outputs…</p>
<p>R = depth<br>
G = (diffuse) color index<br>
B = screen space normal X<br>
A = screen space normal Y</p>
<p>This all works incredibly well with floating point textures (we could have gotten SSAO to work with this, if we’d gotten the production time) and works quite OK with normal unsigned byte textures. 8 bit precision on the depth doesn’t work for SSAO but is good enough for DoF. The live version of Build with Chrome uses unsigned byte textures. This could be updated so machines with support for floating point textures gets SSAO, for example. </p>
<p>The data problem mentioned above, comes from having to deal with color as an index. All textures need to be converted to index textures and all use the same palette. In the expand shaders (more about that soon) we simply use the index as an UV-coordinate and sample the actual color from the palette texture. The palette texture is one pixel high and 256 pixels wide. </p>
<h2>Browse Renderer – Deferred Rendering, Part 2</h2>
<p>Because there was DoF in the design this means the post shader, which is responsible for putting out the final picture, had to sample a lot of other fragments for each fragment it put out (the same goes for SSAO and FXAA, the anti-aliasing technique we use). </p>
<p>Because the deferred shaders put out such limited information and there’s need to process this data before you can actually use it in a meaningful way, we invented something we call expand shaders. There are three expand shaders, which all are very simple in themselves, that converts the deferred buffer into three buffers containing:</p>
<ul>
<li>Camera relative position of a pixel</li>
<li>Normal of a pixel</li>
<li>Color of a pixel</li>
</ul>
<p>Or at least in theory. In practice we didn’t need all this information and removed some of this, to optimize. Again, this works amazingly good with floating point textures and OK with unsigned byte textures (the position buffer is very approximate, to say the least). These three buffers are then sent to the post shader, which does all the compositing and lighting.</p>
<h2>Browse Renderer – Deferred Rendering, Part 3</h2>
<p>This will mainly be about the pegs, but first a little about light. We only use directional lights and we solved this using a separate light pass. It’s a simple shader that renders what could be described as a camera projected, lit ball to a texture (there’s no geometry, but the result looks like a lit ball plus some). This texture then simply becomes a lookup table for the screen space normal that the deferred shader put out. This means we can have almost as many lights we like, with very little per-pixel cost.</p>
<p>Ok, the pegs. From day one we knew that real geometry wasn’t an option – it’s simply too much to calculate and draw. So we pulled a trick that we came to call ”camera mapping”. Not sure it’s the right terminology. Anyway, what we do is we render a single, high resolution peg to a texture, using an orthographic camera. (Side note: we only render the screen space normals (BA-channel). The other two channels are used to create edges that mark the tiny gap between the bricks, but that’s another story). </p>
<p>To get the mapping right, you use a screen projected version of the UV-coordinate. In Build with Chrome, this projection is actually done in JavaScript as there’s only four UV coordinates in the entire world.  </p>
<p>Now, that might sound simple but when you have bricks that have more than one peg (most of them), you need to get the UV-wrapping to work for you as the top side is just two triangles, no matter how many pegs it has. This took some time to figure out, but in the middle of the night, it all came to me. What you need to do is to “unwrap” it…</p>
<p>The resulting buffer looks really weird, but because the process is reversed on screen it all looks dandy in the end. </p>
<p>There are some real limitations to the camera mapping technique. First you can’t look towards the horizon, as the pegs have no height. Secondly, pegs in the edges of the screen becomes slightly distorted. This explains the tight perspective the browse mode has. I think we can push it and make a more free browse camera, but we decided to stay on the safe side right now. Hopefully we’ll get the chance to improve this later on.</p>
<h2>Wrap Up</h2>
<p>I found two interesting/annoying bugs during the development:</p>
<p>1. If you have an FBO that uses a depth buffer, you also need to have the stencil buffer attached or the depth buffer will fail on certain Macs. Probably there’s no performance loss if you have stencil write disabled.<br>
2. On some other Macs, using ints in shaders fail. You have to use floor( theFloatValue ).</p>
<p>This was (and hopefully continues to be) one of the most awesome projects I’ve been part of. Thanks to all wonderful people that was involved!</p>
<p>For you geeks who are really interested in WebGL and like to know more about the details, please don’t hesitate to <a href="https://twitter.com/mikaelemtinger">contact me on twitter</a>.  </p>
	</div>
		<span class="date">2012+03+13</span>
	<h1>A few updates</h1>
	<div id="content">
		<p>Today we uploaded a <a href="https://github.com/empaempa/GLOW/commits/master">few handy changes to the repo</a>. Among these, we’d say these are the most interesting:</p>
<ul>
<li>GLOW.Float and GLOW.Int now support arrays as constructor parameter. This is very good to have when you have uniform arrays in your shaders.</li>
<li>GLOW.Matrix3.extractFromMatrix4() was added so you easily can get the rotation part of the GLOW.Matrix4 into your GLOW.Matrix3.</li>
<li>The GLOW.Compiler doesn’t call the GLOW.Texture.init() if there’s no texture there to initialize. This allows you to init your shader without a texture set.</li>
<li>We added GLOW.Geometry.Cylinder so you can create cylinders easily.</li>
<li>We added interleaved attributes to the cache (I have no idea why we hadn’t this before, but now it’s there :)</li>
</ul>
<p>Enjoy! </p>
	</div>
		<span class="date">2011+12+27</span>
	<h1>Refactored .elements</h1>
	<div id="content">
		<p>To make it easier and more logical to activate GL.drawArrays (<a href="http://i-am-glow.com/?p=224">see previous post</a>) we’ve thrown away the good old elements property and changed it into…</p>
<pre class="prettyprint">var shaderConfig = {
  indices: myArrayOfIndices,
  primitives: GL.TRIANGLES,
  data: {
    // attributes and uniforms
  },
  usage: {
    primitives: GL.DYNAMIC_DRAW
  }
}
</pre>
<p>(First a side note: elements is now primitives in the usage object). As you can see we’ve split elements into indices and primitives, where…</p>
<ul>
<li><strong>indices</strong> is the array of indices</li>
<li><strong>primitives</strong> is the type of primitive you’d like to use</li>
</ul>
<p>If you leave out the primitives property, it defaults to GL.TRIANGLE. Also, the good old…</p>
<ul>
<li>triangles</li>
<li>triangleStrip</li>
<li>triangleFan</li>
<li>points</li>
<li>lines</li>
<li>lineLoop</li>
<li>lineStrip</li>
</ul>
<p>… properties still work and automatically sets the primitive property.</p>
<p>Now, to use GL.drawArrays instead of GL.drawElements you simply leave out the indices property…</p>
<pre class="prettyprint">var shaderConfig = {
  primitives: GL.POINTS,
  data: {
    // attributes and uniforms
  }
}
</pre>
<p>As you see, you no longer have to set the amount of primitives to draw (this is calculated from the attribute length). </p>
<p>Thanks <a href="https://github.com/neilmendoza">Neil Mendoza</a> for the excellent suggestion.<br>
Hope you like it! </p>
	</div>
		<span class="date">2011+12+25</span>
	<h1>Added support for drawArrays</h1>
	<div id="content">
		<p>As <a href="https://github.com/neilmendoza">Neil Mendoza</a> rightfully pointed out, GLOW only supported drawElements. We’ve now added support for drawArrays. It’s quite simple to do, you just…</p>
<pre class="prettyprint">var shaderConfig = {
  <del datetime="2011-12-27T16:21:06+00:00">triangles: 10 * 3</del>
  primitives: GL.POINTS,
  data: {
    // attributes and uniforms
  }
}

var shader = new GLOW.Shader( shaderConfig );
shader.draw();
</pre>
<p>As you can see the only difference is that you, instead of creating an array of indices, tell the shader <del datetime="2011-12-27T16:21:06+00:00">the length of the arrays to draw</del> which type of primitive you’d like to draw. As drawArrays doesn’t use indicies like drawElements you’re not limited by the 65535-limit imposed by the Uint16Array used by drawElements. </p>
<p>Another nerdy addition is the GLOW.Elements.offset property that’s been added. This can be used to create animation-like behaviors, moving over the attributes. Please note that you have to keep the GLOW.Elements.length in check, so you don’t run outside the attribute buffers.</p>
<p>We’ve updated the <a href="http://empaempa.github.com/GLOW/examples/complicated">particle thingy</a> we launched some week ago as well as killing some bugs related to cloning textures. </p>
<p>Please pull!</p>
	</div>
		<span class="date">2011+12+12</span>
	<h1>FBO Simulations</h1>
	<div id="content">
		<p>It’s been a while but we’ve just added a new tutorial on how to use FBO and GL.FLOAT for complex shader simulations. <a href="http://i-am-glow.com/?page_id=183">Click here to get into the game</a>. <a href="http://empaempa.github.com/GLOW/examples/complicated">And here to see an example.</a></p>
	</div>
		<span class="date">2011+07+21</span>
	<h1>GLOW.Texture Changes</h1>
	<div id="content">
		<p>We just refactored and simplified the GLOW.Texture. Read all about the new texture capabilities <a href="http://i-am-glow.com/?page_id=173">here</a>.</p>
	</div>
		<span class="date">2011+07+15</span>
	<h1>Interleaved Attributes</h1>
	<div id="content">
		<p><strong>GLOW had one feature, the cache, but we just added its second – automatically interleaved attribute data.</strong></p>
<p>Interleaved attributes is a performance improvement, which in some cases can make a big difference but really is a very nerdy feature. It’s not widely supported by existing WebGL frameworks so I’ll try to explain what it is and why you like to have it.</p>
<p>Instead of having one VBO for vertices, another for normals and a third for UV coordinates, you simply interleave them into one VBO. So instead of…</p>
<pre class="prettyprint">VBO A: Vertex Vertex Vertex...
VBO B: Normal Normal Normal...
VBO C: UV UV UV...</pre>
<p>…you get…</p>
<pre class="prettyprint">VBO: Vertex Normal UV Vertex Normal UV...</pre>
<p>The good thing with this is that you only have to bind one buffer instead of one per attribute, when setting up the attributes prior to the draw call. </p>
<p>To get the right data to the right attribute, WebGL uses something called Stride and Offset (or Pointer). You can read all about it <a href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml">here</a>. This is all handled internally by GLOW, and you’ll not even notice unless you use WebGL Inspector and look at the trace. </p>
<p>Most of the time you like this to be enabled and just work but in some cases you might want to control how the attributes are interleaved or not interleaved at all. This is possible through the shader definition object that you pass into the GLOW.Shader constructor…</p>
<pre class="prettyprint">var shaderInfo = {
  vertexShader: "...vertex shader code...",
  fragmentShader: "...fragment shader code...",
  data: { ...all uniform, attribute and texture data... },
  elements: [ ...UInt16Array containing element info... ],
  interleave: {
    vertices: false,
  }
}</pre>
<p>In this example the attribute called ”vertices” won’t be interleaved (and work just as an ordinary GLOW.Attribute) and all other attributes will be automatically interleaved.  </p>
<pre class="prettyprint">var shaderInfo = {
  vertexShader: "...vertex shader code...",
  fragmentShader: "...fragment shader code...",
  data: { ...all uniform, attribute and texture data... },
  elements: [ ...UInt16Array containing element info... ],
  interleave: {
    vertices: false,
    normals: 5,
    uvs: 5,
    speed: 1,
    acceleration: 1
  }
}</pre>
<p>In this example the ”vertices” attribute won’t be interleaved, ”normals” and ”uvs” will be interleaved together and ”speed” and ”acceleration” will be interleaved together. The number can be any number you like – think of it as the id of the interleaved VBO you’re creating. If you happen to have even more attributes than the ones controlled in the interleave object, they will be automatically interleaved.</p>
<p>You can even control the usage for interleaved attributes by…   </p>
<pre class="prettyprint">var shaderInfo = {
  vertexShader: "...vertex shader code...",
  fragmentShader: "...fragment shader code...",
  data: { ...all uniform, attribute and texture data... },
  elements: [ ...UInt16Array containing element info... ],
  interleave: {
    vertices: false,
    normals: 5,
    uvs: 5,
    speed: 1,
    acceleration: 1
  },
  usage: {
    normals: GL.DYNAMIC_DRAW,
    uvs: GL.DYNAMIC_DRAW
  }
}</pre>
<p>…which will make the ”normals” and ”uvs” buffer use DYNAMIC_DRAW. If you only define usage for one of the attributes in an interleaved buffer, GLOW will throw a warning and default back to STATIC_DRAW.</p>
<p>Last, some details, a new object called GLOW.InterleavedAttributes has been introduced. You cannot use the clone except-property on an interleaved attribute (as it’s now part of a set of interleaved attributes). The interleaved attribute name is generated by the attributes in the set – like ”vertices_uvs_normals” for example, and is accesible directly on the GLOW.Shader like other attributes (and uniforms).  </p>
	</div>
		<span class="date">2011+07+03</span>
	<h1>Usage</h1>
	<div id="content">
		<p><strong>Usage in WebGL is used for hinting the GPU how to store data. This parameter is now supported by GLOW.</strong></p>
<p>The GLOW shader data object has a new property, simply called usage…</p>
<pre class="prettyprint">var shaderData = {
  vertexShader: "...the vertex shader code...",
  fragmentShader: "...the fragment shader code...",
  data: {
    viewMatrix: new GLOW.Matrix4(),
    vertices: myFloat32ArrayWithVertices,
    uvs: myFloat32ArrayWithUVs,
    ...and all other uniforms and attributes...
  }
  usage: {
    vertices: GL.DYNAMIC_DRAW,
    uvs: GL.STREAM_DRAW,
    triangles: GL.DYNAMIC_DRAW
  }
  triangles: myUint16ArrayWithTriangles
}</pre>
<p>As you see, I use the global GL object for parameters – make sure that a GLOW.Context has been created before you create the shader data object. </p>
<ul>
<li><strong>GL.DYNAMIC_DRAW</strong> is for buffers that are used often and updated often</li>
<li><strong>GL.STREAM_DRAW</strong> is for buffers that are initialized once and seldom drawn.</li>
<li><strong>GL.STATIC_DRAW</strong> (default) is for buffers that are initialized once and drawn often.</li>
</ul>
<p>Note that the elements (in this case triangles) also can be subject to usage. You don’t have to define the usage property and if you do, you only have to set it for data that use GL.STREAM_DRAW or GL.DYNAMIC_DRAW.</p>
	</div>
		<span class="date">2011+07+03</span>
	<h1>Point, Lines, Triangles</h1>
	<div id="content">
		<p><strong>Sometimes you don’t want to draw triangles, but lines and points. Now GLOW has support for this as well as some other types.</strong></p>
<p>As you know, this is the GLOW shader data object…</p>
<pre class="prettyprint">var shaderData = {
  vertexShader: "...the vertex shader code...",
  fragmentShader: "...the fragment shader code...",
  data: {
    viewMatrix: new GLOW.Matrix4(),
    vertices: myFloat32ArrayWithVertices,
    ...and all other uniforms and attributes...
  }
  elements: myUint16ArrayWithElements
}
</pre>
<p>As of today the elements property can be switched to any of the following…</p>
<ul>
<li>points</li>
<li>lines</li>
<li>lineLoop</li>
<li>lineStrip</li>
<li>triangles</li>
<li>triangleStrip</li>
<li>triangleFan</li>
</ul>
<p>…which are the different element types that WebGL supports. Elements is the same as triangles, but we decided to keep it for now. If you’re into details, you can see that the GLOW.Elements have some new parameters – data, type and usage (more about usage in the next post).</p>
	</div>
		<span class="date">2011+06+22</span>
	<h1>Benefits with GLOW</h1>
	<div id="content">
		<p><strong>Several people have asked me why they should use GLOW when there’re a lot more competent libraries out there. It’s a good question, which I’ll try to answer here.</strong></p>
<p>GLOW is a WebGL wrapper, so you’re flying very LOW over the GL – that’s where the name comes from. This also means that GLOW is not for beginners but for you with some experience of WebGL or OpenGL. It also means that it’s not a WebGL 3D framework (like Three.js). It’s just a wrapper.  </p>
<p>Given that you have experience, you’re probably familiar with code looking like…</p>
<pre class="prettyprint">GL.useProgram( program );
GL.uniformMatrix4fv( viewMatrixLoc, false, viewMatrix );
GL.uniformMatrix4fv( projMatrixLoc, false, projMatrix );
GL.uniform1i( sampleLoc, 0 );
GL.activeTexture( GL.TEXTURE0 );
GL.bindTexture( GL.TEXTURE_2D, texture );
GL.enableVertexAttribArray(0);
GL.enableVertexAttribArray(1);
GL.enableVertexAttribArray(2);
GL.bindBuffer( GL.ARRAY_BUFFER, vertices );
GL.vertexAttribPointer( 0, 3, GL.FLOAT, false, 0, 0 );
GL.bindBuffer( GL.ARRAY_BUFFER, uvs );
GL.vertexAttribPointer( 1, 2, GL.FLOAT, false, 0, 0 );
GL.bindBuffer( GL.ARRAY_BUFFER, normals );
GL.vertexAttribPointer( 2, 3, GL.FLOAT, false, 0, 0 );
GL.bindBuffer( GL.ELEMENT_ARRAY_BUFFER, faces );
GL.drawElements( GL.TRIANGLES, 36, GL.UNSIGNED_SHORT, 0 );
</pre>
<p>This is pretty much the only way to draw something with WebGL – it’s designed this way. GLOW wraps this with a tiny overhead <a href="http://i-am-glow.com/?p=18">(most of which is the cache)</a> and all you do is…</p>
<pre class="prettyprint">myShader.draw();</pre>
<p>It’s in your shader code the magic happens and we think this is where you should spend your time. The shader data format is similar to the Three.js custom shader format – only slightly simpler, all to get you started within minutes… </p>
<pre class="prettyprint">var shaderData = {
  vertexShader: "...the vertex shader code...",
  fragmentShader: "...the fragment shader code...",
  data: {
    viewMatrix: new GLOW.Matrix4(),
    vertices: myFloat32ArrayWithVertices,
    ...and all other uniforms and attributes...
  }
  elements: myUint16ArrayWithElements
}

var shader = new GLOW.Shader( shaderData );
shader.draw();
</pre>
<p>GLOW comes with an extras library including matrices, vectors, hierarchies, geometry parsers and other helpful objects, all (most probably) working out of the box. As GLOW is just a wrapper, it’s compatible with all other WebGL libraries and can be used to extend these in all possible ways. </p>
<p>So, the benefits are:</p>
<ul>
<li>You get close to WebGL without having to deal with the WebGL API</li>
<li>It’s very easy to create shaders</li>
<li>There are a lot of extras that helps you get going</li>
<li>It’s compatible with all other WebGL frameworks</li>
</ul>
<p>Enjoy!</p>
	</div>
	</div>

<div id="sidebar">
<div id="sidebarTitle"><span class="text">GET GLOW</span></div>
<ul>
	<li><a href="http://www.github.com/empaempa/GLOW/">Here</a></li>
</ul>
<div id="sidebarTitle"><span class="text">COMMENT</span></div>
<ul>
	<li><a href="https://github.com/empaempa/GLOW/issues">Here</a></li>
</ul>

<div id="sidebarTitle"><span class="text">TUTORIALS</span></div>
<ul>
	<li class="page_item page-item-2"><a href="http://i-am-glow.com/?page_id=2" title="Hello Cube!">Hello Cube!</a></li>
<li class="page_item page-item-183"><a href="http://i-am-glow.com/?page_id=183" title="Hello FBO Simulation">Hello FBO Simulation</a></li>
<li class="page_item page-item-61"><a href="http://i-am-glow.com/?page_id=61" title="Hello Clone!">Hello Clone!</a></li>
<li class="page_item page-item-75"><a href="http://i-am-glow.com/?page_id=75" title="Hello Three.js">Hello Three.js</a></li>
<li class="page_item page-item-96"><a href="http://i-am-glow.com/?page_id=96" title="Hello FBO">Hello FBO</a></li>
<li class="page_item page-item-173"><a href="http://i-am-glow.com/?page_id=173" title="Hello Textures!">Hello Textures!</a></li>
</ul>

<div id="sidebarTitle"><span class="text">BLOG ARCHIVE</span></div>
<ul>
	<li><a href="http://i-am-glow.com/?p=246">Build With Chrome: GLego</a></li>
	<li><a href="http://i-am-glow.com/?p=243">A few updates</a></li>
	<li><a href="http://i-am-glow.com/?p=233">Refactored .elements</a></li>
	<li><a href="http://i-am-glow.com/?p=224">Added support for drawArrays</a></li>
	<li><a href="http://i-am-glow.com/?p=219">FBO Simulations</a></li>
	<li><a href="http://i-am-glow.com/?p=178">GLOW.Texture Changes</a></li>
	<li><a href="http://i-am-glow.com/?p=165">Interleaved Attributes</a></li>
	<li><a href="http://i-am-glow.com/?p=155">Usage</a></li>
	<li><a href="http://i-am-glow.com/?p=150">Point, Lines, Triangles</a></li>
	<li><a href="http://i-am-glow.com/?p=133">Benefits with GLOW</a></li>
	<li><a href="http://i-am-glow.com/?p=115">Three.js and GLOW</a></li>
	<li><a href="http://i-am-glow.com/?p=106">2D Shaders</a></li>
	<li><a href="http://i-am-glow.com/?p=94">Comments</a></li>
	<li><a href="http://i-am-glow.com/?p=89">The Global GL</a></li>
	<li><a href="http://i-am-glow.com/?p=87">Compatibility</a></li>
	<li><a href="http://i-am-glow.com/?p=56">Uniforms and Attributes</a></li>
	<li><a href="http://i-am-glow.com/?p=18">Cache is King</a></li>
</ul>

<div id="sidebarTitle"><span class="text">FOLLOW ON TWITTER</span></div>
<ul>
	<li><a href="http://www.twitter.com/mikaelemtinger">Mikael Emtinger</a></li>
	<li><a href="http://www.twitter.com/olov">Olov Lassus</a></li>
</ul>
<div id="sidebarTitle"><span class="text">CIRCLE US ON G+</span></div>
<a href="https://plus.google.com/104860497579148778310?prsrc=3" style="text-decoration: none;"><img src="./icons-and-styles/github-icon.png" width="32" height="32" style="border: 0;"></a><p>This blog uses a theme dubbed <strong><a href="http://p41studios.com/">Angebot by P41 Studios.</a></strong>.</p>
</div>
</div></body></html>